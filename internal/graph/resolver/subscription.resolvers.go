package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"jobfai-analytics/internal/graph"
	"jobfai-analytics/internal/graph/model"
	"jobfai-analytics/internal/models"
)

// GameCreated is the resolver for the gameCreated field.
func (r *subscriptionResolver) GameCreated(ctx context.Context) (<-chan *models.Game, error) {
	// Create a channel to send game updates
	gameChan := make(chan *models.Game, 1)

	// Get a unique ID for this subscription
	subID := r.subscriptionManager.Subscribe("game:created", func(data interface{}) error {
		game, ok := data.(*models.Game)
		if !ok {
			return fmt.Errorf("invalid data type for game:created event")
		}

		// Send the game to the channel
		select {
		case gameChan <- game:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	// Handle cleanup when the context is done
	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe("game:created", subID)
		close(gameChan)
	}()

	return gameChan, nil
}

// GameUpdated is the resolver for the gameUpdated field.
func (r *subscriptionResolver) GameUpdated(ctx context.Context, gameID *string) (<-chan *models.Game, error) {
	gameChan := make(chan *models.Game, 1)

	eventName := "game:updated"
	if gameID != nil {
		eventName = fmt.Sprintf("game:updated:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		game, ok := data.(*models.Game)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific game if gameID is provided
		if gameID != nil && game.GameID != *gameID {
			return nil
		}

		select {
		case gameChan <- game:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(gameChan)
	}()

	return gameChan, nil
}

// GameDeleted is the resolver for the gameDeleted field.
func (r *subscriptionResolver) GameDeleted(ctx context.Context, gameID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "game:deleted"
	if gameID != nil {
		eventName = fmt.Sprintf("game:deleted:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific game if gameID is provided
		if gameID != nil && *deletedID != *gameID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// CompetenceCreated is the resolver for the competenceCreated field.
func (r *subscriptionResolver) CompetenceCreated(ctx context.Context, gameID *string) (<-chan *models.Competence, error) {
	competenceChan := make(chan *models.Competence, 1)

	eventName := "competence:created"
	if gameID != nil {
		eventName = fmt.Sprintf("competence:created:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		competence, ok := data.(*models.Competence)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send competences for the specific game if gameID is provided
		if gameID != nil && competence.GameID != *gameID {
			return nil
		}

		select {
		case competenceChan <- competence:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(competenceChan)
	}()

	return competenceChan, nil
}

// CompetenceUpdated is the resolver for the competenceUpdated field.
func (r *subscriptionResolver) CompetenceUpdated(ctx context.Context, competenceID *string) (<-chan *models.Competence, error) {
	competenceChan := make(chan *models.Competence, 1)

	eventName := "competence:updated"
	if competenceID != nil {
		eventName = fmt.Sprintf("competence:updated:%s", *competenceID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		competence, ok := data.(*models.Competence)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}
		id := fmt.Sprintf("%d", competence.CompetenceID)
		// Only send updates for the specific competence if competenceID is provided
		if competenceID != nil && id != *competenceID {
			return nil
		}

		select {
		case competenceChan <- competence:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(competenceChan)
	}()

	return competenceChan, nil
}

// CompetenceDeleted is the resolver for the competenceDeleted field.
func (r *subscriptionResolver) CompetenceDeleted(ctx context.Context, competenceID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "competence:deleted"
	if competenceID != nil {
		eventName = fmt.Sprintf("competence:deleted:%s", *competenceID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific competence if competenceID is provided
		if competenceID != nil && *deletedID != *competenceID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// CompetenceMetricCreated is the resolver for the competenceMetricCreated field.
func (r *subscriptionResolver) CompetenceMetricCreated(ctx context.Context, competenceID *string) (<-chan *models.CompetenceMetric, error) {
	metricChan := make(chan *models.CompetenceMetric, 1)

	eventName := "competence_metric:created"
	if competenceID != nil {
		eventName = fmt.Sprintf("competence_metric:created:%s", *competenceID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		metric, ok := data.(*models.CompetenceMetric)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send metrics for the specific competence if competenceID is provided
		if competenceID != nil {
			compID := fmt.Sprintf("%d", metric.CompetenceID)
			if compID != *competenceID {
				return nil
			}
		}

		select {
		case metricChan <- metric:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(metricChan)
	}()

	return metricChan, nil
}

// CompetenceMetricUpdated is the resolver for the competenceMetricUpdated field.
func (r *subscriptionResolver) CompetenceMetricUpdated(ctx context.Context, metricID *string) (<-chan *models.CompetenceMetric, error) {
	metricChan := make(chan *models.CompetenceMetric, 1)

	eventName := "competence_metric:updated"
	if metricID != nil {
		eventName = fmt.Sprintf("competence_metric:updated:%s", *metricID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		metric, ok := data.(*models.CompetenceMetric)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific metric if metricID is provided
		if metricID != nil {
			id := fmt.Sprintf("%d", metric.MetricID)
			if id != *metricID {
				return nil
			}
		}

		select {
		case metricChan <- metric:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(metricChan)
	}()

	return metricChan, nil
}

// CompetenceMetricDeleted is the resolver for the competenceMetricDeleted field.
func (r *subscriptionResolver) CompetenceMetricDeleted(ctx context.Context, metricID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "competence_metric:deleted"
	if metricID != nil {
		eventName = fmt.Sprintf("competence_metric:deleted:%s", *metricID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific metric if metricID is provided
		if metricID != nil && *deletedID != *metricID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// MetricParameterCreated is the resolver for the metricParameterCreated field.
func (r *subscriptionResolver) MetricParameterCreated(ctx context.Context, metricID *string) (<-chan *model.MetricParameter, error) {
	paramChan := make(chan *model.MetricParameter, 1)

	eventName := "metric_parameter:created"
	if metricID != nil {
		eventName = fmt.Sprintf("metric_parameter:created:%s", *metricID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		param, ok := data.(*model.MetricParameter)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send parameters for the specific metric if metricID is provided
		if metricID != nil && *param.MetricID != *metricID {
			return nil
		}

		select {
		case paramChan <- param:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(paramChan)
	}()

	return paramChan, nil
}

// MetricParameterUpdated is the resolver for the metricParameterUpdated field.
func (r *subscriptionResolver) MetricParameterUpdated(ctx context.Context, paramID *string) (<-chan *model.MetricParameter, error) {
	paramChan := make(chan *model.MetricParameter, 1)

	eventName := "metric_parameter:updated"
	if paramID != nil {
		eventName = fmt.Sprintf("metric_parameter:updated:%s", *paramID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		param, ok := data.(*model.MetricParameter)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific parameter if paramID is provided
		if paramID != nil && param.ParamID != *paramID {
			return nil
		}

		select {
		case paramChan <- param:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(paramChan)
	}()

	return paramChan, nil
}

// MetricParameterDeleted is the resolver for the metricParameterDeleted field.
func (r *subscriptionResolver) MetricParameterDeleted(ctx context.Context, paramID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "metric_parameter:deleted"
	if paramID != nil {
		eventName = fmt.Sprintf("metric_parameter:deleted:%s", *paramID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific parameter if paramID is provided
		if paramID != nil && *deletedID != *paramID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// StageCreated is the resolver for the stageCreated field.
func (r *subscriptionResolver) StageCreated(ctx context.Context, gameID *string) (<-chan *models.Stage, error) {
	stageChan := make(chan *models.Stage, 1)

	eventName := "stage:created"
	if gameID != nil {
		eventName = fmt.Sprintf("stage:created:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		stage, ok := data.(*models.Stage)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send stages for the specific game if gameID is provided
		if gameID != nil && stage.GameID != *gameID {
			return nil
		}

		select {
		case stageChan <- stage:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(stageChan)
	}()

	return stageChan, nil
}

// StageUpdated is the resolver for the stageUpdated field.
func (r *subscriptionResolver) StageUpdated(ctx context.Context, stageID *string) (<-chan *models.Stage, error) {
	stageChan := make(chan *models.Stage, 1)

	eventName := "stage:updated"
	if stageID != nil {
		eventName = fmt.Sprintf("stage:updated:%s", *stageID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		stage, ok := data.(*models.Stage)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific stage if stageID is provided
		if stageID != nil {
			id := fmt.Sprintf("%d", stage.StageID)
			if id != *stageID {
				return nil
			}
		}

		select {
		case stageChan <- stage:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(stageChan)
	}()

	return stageChan, nil
}

// StageDeleted is the resolver for the stageDeleted field.
func (r *subscriptionResolver) StageDeleted(ctx context.Context, stageID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "stage:deleted"
	if stageID != nil {
		eventName = fmt.Sprintf("stage:deleted:%s", *stageID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific stage if stageID is provided
		if stageID != nil && *deletedID != *stageID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// MetricAssignedToStage is the resolver for the metricAssignedToStage field.
func (r *subscriptionResolver) MetricAssignedToStage(ctx context.Context, stageID *string, metricID *string) (<-chan *bool, error) {
	assignedChan := make(chan *bool, 1)

	eventName := "metric:assigned_to_stage"
	if stageID != nil && metricID != nil {
		eventName = fmt.Sprintf("metric:assigned_to_stage:%s:%s", *stageID, *metricID)
	} else if stageID != nil {
		eventName = fmt.Sprintf("metric:assigned_to_stage:%s", *stageID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		type assignmentEvent struct {
			StageID  string
			MetricID string
			Assigned bool
		}

		event, ok := data.(*assignmentEvent)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Filter by stageID and metricID if provided
		if stageID != nil && event.StageID != *stageID {
			return nil
		}
		if metricID != nil && event.MetricID != *metricID {
			return nil
		}

		result := event.Assigned
		select {
		case assignedChan <- &result:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(assignedChan)
	}()

	return assignedChan, nil
}

// MetricRemovedFromStage is the resolver for the metricRemovedFromStage field.
func (r *subscriptionResolver) MetricRemovedFromStage(ctx context.Context, stageID *string, metricID *string) (<-chan *bool, error) {
	removedChan := make(chan *bool, 1)

	eventName := "metric:removed_from_stage"
	if stageID != nil && metricID != nil {
		eventName = fmt.Sprintf("metric:removed_from_stage:%s:%s", *stageID, *metricID)
	} else if stageID != nil {
		eventName = fmt.Sprintf("metric:removed_from_stage:%s", *stageID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		type removalEvent struct {
			StageID  string
			MetricID string
			Removed  bool
		}

		event, ok := data.(*removalEvent)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Filter by stageID and metricID if provided
		if stageID != nil && event.StageID != *stageID {
			return nil
		}
		if metricID != nil && event.MetricID != *metricID {
			return nil
		}

		result := event.Removed
		select {
		case removedChan <- &result:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(removedChan)
	}()

	return removedChan, nil
}

// GameMetricCreated is the resolver for the gameMetricCreated field.
func (r *subscriptionResolver) GameMetricCreated(ctx context.Context, gameID *string) (<-chan *models.GameMetric, error) {
	metricChan := make(chan *models.GameMetric, 1)

	eventName := "game_metric:created"
	if gameID != nil {
		eventName = fmt.Sprintf("game_metric:created:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		metric, ok := data.(*models.GameMetric)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send metrics for the specific game if gameID is provided
		if gameID != nil && metric.GameID != *gameID {
			return nil
		}

		select {
		case metricChan <- metric:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(metricChan)
	}()

	return metricChan, nil
}

// GameMetricUpdated is the resolver for the gameMetricUpdated field.
func (r *subscriptionResolver) GameMetricUpdated(ctx context.Context, metricID *string) (<-chan *models.GameMetric, error) {
	metricChan := make(chan *models.GameMetric, 1)

	eventName := "game_metric:updated"
	if metricID != nil {
		eventName = fmt.Sprintf("game_metric:updated:%s", *metricID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		metric, ok := data.(*models.GameMetric)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific metric if metricID is provided
		if metricID != nil {
			id := fmt.Sprintf("%d", metric.MetricID)
			if id != *metricID {
				return nil
			}
		}

		select {
		case metricChan <- metric:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(metricChan)
	}()

	return metricChan, nil
}

// GameMetricDeleted is the resolver for the gameMetricDeleted field.
func (r *subscriptionResolver) GameMetricDeleted(ctx context.Context, metricID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "game_metric:deleted"
	if metricID != nil {
		eventName = fmt.Sprintf("game_metric:deleted:%s", *metricID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific metric if metricID is provided
		if metricID != nil && *deletedID != *metricID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// GameMetricParameterCreated is the resolver for the gameMetricParameterCreated field.
func (r *subscriptionResolver) GameMetricParameterCreated(ctx context.Context, metricID *string) (<-chan *models.GameMetricParameter, error) {
	paramChan := make(chan *models.GameMetricParameter, 1)

	eventName := "game_metric_parameter:created"
	if metricID != nil {
		eventName = fmt.Sprintf("game_metric_parameter:created:%s", *metricID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		param, ok := data.(*models.GameMetricParameter)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send parameters for the specific metric if metricID is provided
		if metricID != nil {
			id := fmt.Sprintf("%d", param.MetricID)
			if id != *metricID {
				return nil
			}
		}

		select {
		case paramChan <- param:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(paramChan)
	}()

	return paramChan, nil
}

// GameMetricParameterUpdated is the resolver for the gameMetricParameterUpdated field.
func (r *subscriptionResolver) GameMetricParameterUpdated(ctx context.Context, paramID *string) (<-chan *models.GameMetricParameter, error) {
	paramChan := make(chan *models.GameMetricParameter, 1)

	eventName := "game_metric_parameter:updated"
	if paramID != nil {
		eventName = fmt.Sprintf("game_metric_parameter:updated:%s", *paramID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		param, ok := data.(*models.GameMetricParameter)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific parameter if paramID is provided
		if paramID != nil {
			id := fmt.Sprintf("%d", param.ParamID)
			if id != *paramID {
				return nil
			}
		}

		select {
		case paramChan <- param:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(paramChan)
	}()

	return paramChan, nil
}

// GameMetricParameterDeleted is the resolver for the gameMetricParameterDeleted field.
func (r *subscriptionResolver) GameMetricParameterDeleted(ctx context.Context, paramID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "game_metric_parameter:deleted"
	if paramID != nil {
		eventName = fmt.Sprintf("game_metric_parameter:deleted:%s", *paramID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific parameter if paramID is provided
		if paramID != nil && *deletedID != *paramID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// ConstantParameterCreated is the resolver for the constantParameterCreated field.
func (r *subscriptionResolver) ConstantParameterCreated(ctx context.Context, gameID *string) (<-chan *models.ConstantParameter, error) {
	paramChan := make(chan *models.ConstantParameter, 1)

	eventName := "constant_parameter:created"
	if gameID != nil {
		eventName = fmt.Sprintf("constant_parameter:created:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		param, ok := data.(*models.ConstantParameter)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send parameters for the specific game if gameID is provided
		if gameID != nil && param.GameID != *gameID {
			return nil
		}

		select {
		case paramChan <- param:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(paramChan)
	}()

	return paramChan, nil
}

// ConstantParameterUpdated is the resolver for the constantParameterUpdated field.
func (r *subscriptionResolver) ConstantParameterUpdated(ctx context.Context, constID *string) (<-chan *models.ConstantParameter, error) {
	paramChan := make(chan *models.ConstantParameter, 1)

	eventName := "constant_parameter:updated"
	if constID != nil {
		eventName = fmt.Sprintf("constant_parameter:updated:%s", *constID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		param, ok := data.(*models.ConstantParameter)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send updates for the specific parameter if constID is provided
		if constID != nil {
			id := fmt.Sprintf("%d", param.ConstID)
			if id != *constID {
				return nil
			}
		}

		select {
		case paramChan <- param:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(paramChan)
	}()

	return paramChan, nil
}

// ConstantParameterDeleted is the resolver for the constantParameterDeleted field.
func (r *subscriptionResolver) ConstantParameterDeleted(ctx context.Context, constID *string) (<-chan *string, error) {
	deletedIDChan := make(chan *string, 1)

	eventName := "constant_parameter:deleted"
	if constID != nil {
		eventName = fmt.Sprintf("constant_parameter:deleted:%s", *constID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		deletedID, ok := data.(*string)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Only send deletion events for the specific parameter if constID is provided
		if constID != nil && *deletedID != *constID {
			return nil
		}

		select {
		case deletedIDChan <- deletedID:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(deletedIDChan)
	}()

	return deletedIDChan, nil
}

// PlayerPerformanceCalculated is the resolver for the playerPerformanceCalculated field.
func (r *subscriptionResolver) PlayerPerformanceCalculated(ctx context.Context, playerID *string, gameID *string) (<-chan *model.PlayerPerformance, error) {
	perfChan := make(chan *model.PlayerPerformance, 1)

	eventName := "player_performance:calculated"
	if playerID != nil && gameID != nil {
		eventName = fmt.Sprintf("player_performance:calculated:%s:%s", *playerID, *gameID)
	} else if playerID != nil {
		eventName = fmt.Sprintf("player_performance:calculated:%s", *playerID)
	} else if gameID != nil {
		eventName = fmt.Sprintf("player_performance:calculated:game:%s", *gameID)
	}

	subID := r.subscriptionManager.Subscribe(eventName, func(data interface{}) error {
		perf, ok := data.(*model.PlayerPerformance)
		if !ok {
			return fmt.Errorf("invalid data type for %s event", eventName)
		}

		// Filter by playerID and gameID if provided
		if playerID != nil && perf.PlayerID != *playerID {
			return nil
		}
		if gameID != nil && perf.GameID != *gameID {
			return nil
		}

		select {
		case perfChan <- perf:
		default:
			// Channel buffer is full, skip this update
		}
		return nil
	})

	go func() {
		<-ctx.Done()
		r.subscriptionManager.Unsubscribe(eventName, subID)
		close(perfChan)
	}()

	return perfChan, nil
}

// Subscription returns graph.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
