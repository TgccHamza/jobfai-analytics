package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"jobfai-analytics/internal/graph"
	"jobfai-analytics/internal/graph/model"
	"jobfai-analytics/internal/models"
	"jobfai-analytics/internal/services"
	"strconv"

	"github.com/google/uuid"
)

// CreateGame is the resolver for the createGame field.
// CreateGame is the resolver for the createGame field.
func (r *mutationResolver) CreateGame(ctx context.Context, input model.GameInput) (*models.Game, error) {
	// Generate a unique ID for the game using UUID
	gameID := uuid.New().String() // Truncate to 20 chars to match the DB column size

	game := &models.Game{
		GameID:      gameID,
		GameName:    input.GameName,
		Description: *input.Description,
		Active:      *input.Active,
	}

	err := r.GameService.CreateGame(game)
	if err != nil {
		return nil, fmt.Errorf("failed to create game: %w", err)
	}

	return game, nil
}

// UpdateGame is the resolver for the updateGame field.
func (r *mutationResolver) UpdateGame(ctx context.Context, input model.GameUpdateInput) (*models.Game, error) {
	// First fetch the existing game
	game, err := r.GameService.GetGameByID(input.GameID)
	if err != nil {
		return nil, fmt.Errorf("failed to find game: %w", err)
	}

	if game == nil {
		return nil, fmt.Errorf("game not found with ID: %s", input.GameID)
	}

	// Update fields
	if input.GameName != nil {
		game.GameName = *input.GameName
	}
	if input.Description != nil {
		game.Description = *input.Description
	}
	if input.Active != nil {
		game.Active = *input.Active
	}

	// Save the updated game
	err = r.GameService.UpdateGame(game)
	if err != nil {
		return nil, fmt.Errorf("failed to update game: %w", err)
	}

	return game, nil
}

// DeleteGame is the resolver for the deleteGame field.
func (r *mutationResolver) DeleteGame(ctx context.Context, gameID string) (*bool, error) {
	err := r.GameService.DeleteGame(gameID)
	if err != nil {
		return nil, fmt.Errorf("failed to delete game: %w", err)
	}

	success := true
	return &success, nil
}

// CreateCompetence is the resolver for the createCompetence field.
func (r *mutationResolver) CreateCompetence(ctx context.Context, input model.CompetenceInput) (*models.Competence, error) {
	competence := &models.Competence{
		GameID:         input.GameID,
		CompetenceKey:  input.CompetenceKey,
		CompetenceName: input.CompetenceName,
		Benchmark:      *input.Benchmark,
		Description:    *input.Description,
		Weight:         *input.Weight,
	}

	err := r.CompetenceService.CreateCompetence(competence)
	if err != nil {
		return nil, fmt.Errorf("failed to create competence: %w", err)
	}

	return competence, nil
}

// UpdateCompetence is the resolver for the updateCompetence field.
func (r *mutationResolver) UpdateCompetence(ctx context.Context, input model.CompetenceUpdateInput) (*models.Competence, error) {
	competenceID, err := strconv.Atoi(input.CompetenceID)
	if err != nil {
		return nil, fmt.Errorf("invalid competence ID format: %w", err)
	}

	// Fetch the existing competence
	competence, err := r.CompetenceService.GetCompetenceByID(competenceID)
	if err != nil {
		return nil, fmt.Errorf("failed to find competence: %w", err)
	}

	if competence == nil {
		return nil, fmt.Errorf("competence not found with ID: %s", input.CompetenceID)
	}

	// Update fields
	if input.CompetenceKey != nil {
		competence.CompetenceKey = *input.CompetenceKey
	}
	if input.CompetenceName != nil {
		competence.CompetenceName = *input.CompetenceName
	}
	if input.Benchmark != nil {
		competence.Benchmark = *input.Benchmark
	}
	if input.Description != nil {
		competence.Description = *input.Description
	}
	if input.Weight != nil {
		competence.Weight = *input.Weight
	}

	// Save the updated competence
	err = r.CompetenceService.UpdateCompetence(competence)
	if err != nil {
		return nil, fmt.Errorf("failed to update competence: %w", err)
	}

	return competence, nil
}

// DeleteCompetence is the resolver for the deleteCompetence field.
func (r *mutationResolver) DeleteCompetence(ctx context.Context, competenceID string) (*bool, error) {
	id, err := strconv.Atoi(competenceID)
	if err != nil {
		return nil, fmt.Errorf("invalid competence ID format: %w", err)
	}

	err = r.CompetenceService.DeleteCompetence(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete competence: %w", err)
	}

	success := true
	return &success, nil
}

// CreateCompetenceMetric is the resolver for the createCompetenceMetric field.
func (r *mutationResolver) CreateCompetenceMetric(ctx context.Context, input model.CompetenceMetricInput) (*models.CompetenceMetric, error) {
	competenceID, err := strconv.Atoi(input.CompetenceID)
	if err != nil {
		return nil, fmt.Errorf("invalid competence ID format: %w", err)
	}

	metric := &models.CompetenceMetric{
		CompetenceID:      competenceID,
		MetricKey:         input.MetricKey,
		MetricName:        input.MetricName,
		Formula:           input.Formula,
		MetricDescription: *input.MetricDescription,
		Weight:            *input.Weight,
	}

	err = r.MetricService.CreateCompetenceMetric(metric)
	if err != nil {
		return nil, fmt.Errorf("failed to create competence metric: %w", err)
	}

	return metric, nil
}

// UpdateCompetenceMetric is the resolver for the updateCompetenceMetric field.
func (r *mutationResolver) UpdateCompetenceMetric(ctx context.Context, input model.CompetenceMetricUpdateInput) (*models.CompetenceMetric, error) {
	metricID, err := strconv.Atoi(input.MetricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	// Fetch the existing metric
	metric, err := r.MetricService.GetCompetenceMetricByID(metricID)
	if err != nil {
		return nil, fmt.Errorf("failed to find competence metric: %w", err)
	}

	if metric == nil {
		return nil, fmt.Errorf("competence metric not found with ID: %s", input.MetricID)
	}

	// Update fields
	if input.MetricKey != nil {
		metric.MetricKey = *input.MetricKey
	}
	if input.MetricName != nil {
		metric.MetricName = *input.MetricName
	}
	if input.Formula != nil {
		metric.Formula = *input.Formula
	}
	if input.MetricDescription != nil {
		metric.MetricDescription = *input.MetricDescription
	}
	if input.Weight != nil {
		metric.Weight = *input.Weight
	}

	// Save the updated metric
	err = r.MetricService.UpdateCompetenceMetric(metric)
	if err != nil {
		return nil, fmt.Errorf("failed to update competence metric: %w", err)
	}

	return metric, nil
}

// DeleteCompetenceMetric is the resolver for the deleteCompetenceMetric field.
func (r *mutationResolver) DeleteCompetenceMetric(ctx context.Context, metricID string) (*bool, error) {
	id, err := strconv.Atoi(metricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	err = r.MetricService.DeleteCompetenceMetric(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete competence metric: %w", err)
	}

	success := true
	return &success, nil
}

// CreateMetricParameter is the resolver for the createMetricParameter field.
func (r *mutationResolver) CreateMetricParameter(ctx context.Context, input model.MetricParameterInput) (*model.MetricParameter, error) {
	metricID, err := strconv.Atoi(input.MetricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	parameter := &models.CompetenceMetricParameter{
		MetricID:    metricID,
		ParamKey:    input.ParamKey,
		ParamName:   input.ParamName,
		Description: *input.Description,
		ParamType:   input.ParamType,
		IsRequired:  *input.IsRequired,
	}

	err = r.MetricService.CreateCompetenceMetricParameter(parameter)
	if err != nil {
		return nil, fmt.Errorf("failed to create metric parameter: %w", err)
	}

	// Convert to GraphQL model
	result := &model.MetricParameter{
		ParamID:     strconv.Itoa(parameter.ParamID),
		MetricID:    &input.MetricID,
		ParamKey:    &parameter.ParamKey,
		ParamName:   &parameter.ParamName,
		Description: &parameter.Description,
		ParamType:   &input.ParamType,
		IsRequired:  &parameter.IsRequired,
	}

	return result, nil
}

// UpdateMetricParameter is the resolver for the updateMetricParameter field.
func (r *mutationResolver) UpdateMetricParameter(ctx context.Context, input model.MetricParameterUpdateInput) (*model.MetricParameter, error) {
	paramID, err := strconv.Atoi(input.ParamID)
	if err != nil {
		return nil, fmt.Errorf("invalid parameter ID format: %w", err)
	}

	// Fetch the existing parameter
	parameter, err := r.MetricService.GetCompetenceMetricParameterByID(paramID)
	if err != nil {
		return nil, fmt.Errorf("failed to find metric parameter: %w", err)
	}

	if parameter == nil {
		return nil, fmt.Errorf("metric parameter not found with ID: %s", input.ParamID)
	}

	// Update fields
	if input.ParamKey != nil {
		parameter.ParamKey = *input.ParamKey
	}
	if input.ParamName != nil {
		parameter.ParamName = *input.ParamName
	}
	if input.Description != nil {
		parameter.Description = *input.Description
	}
	if input.ParamType != nil {
		parameter.ParamType = *input.ParamType
	}
	if input.IsRequired != nil {
		parameter.IsRequired = *input.IsRequired
	}

	// Save the updated parameter
	err = r.MetricService.UpdateMetricParameter(parameter)
	if err != nil {
		return nil, fmt.Errorf("failed to update metric parameter: %w", err)
	}

	paramIDStr := strconv.Itoa(parameter.ParamID)
	metricIDStr := strconv.Itoa(parameter.MetricID)

	// Convert to GraphQL model
	result := &model.MetricParameter{
		ParamID:     paramIDStr,
		MetricID:    &metricIDStr,
		ParamKey:    &parameter.ParamKey,
		ParamName:   &parameter.ParamName,
		Description: &parameter.Description,
		ParamType:   &parameter.ParamType,
		IsRequired:  &parameter.IsRequired,
	}

	return result, nil
}

// DeleteMetricParameter is the resolver for the deleteMetricParameter field.
func (r *mutationResolver) DeleteMetricParameter(ctx context.Context, paramID string) (*bool, error) {
	id, err := strconv.Atoi(paramID)
	if err != nil {
		return nil, fmt.Errorf("invalid parameter ID format: %w", err)
	}

	err = r.MetricService.DeleteMetricParameter(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete metric parameter: %w", err)
	}

	success := true
	return &success, nil
}

// CreateStage is the resolver for the createStage field.
func (r *mutationResolver) CreateStage(ctx context.Context, input model.StageInput) (*models.Stage, error) {
	stage := &models.Stage{
		GameID:      input.GameID,
		StageName:   input.StageName,
		StageKey:    input.StageKey,
		StageOrder:  int(input.StageOrder),
		Description: *input.Description,
	}

	err := r.StageService.CreateStage(stage)
	if err != nil {
		return nil, fmt.Errorf("failed to create stage: %w", err)
	}

	return stage, nil
}

// UpdateStage is the resolver for the updateStage field.
func (r *mutationResolver) UpdateStage(ctx context.Context, input model.StageUpdateInput) (*models.Stage, error) {
	stageID, err := strconv.Atoi(input.StageID)
	if err != nil {
		return nil, fmt.Errorf("invalid stage ID format: %w", err)
	}

	// Fetch the existing stage
	stage, err := r.StageService.GetStageByID(stageID)
	if err != nil {
		return nil, fmt.Errorf("failed to find stage: %w", err)
	}

	if stage == nil {
		return nil, fmt.Errorf("stage not found with ID: %s", input.StageID)
	}

	// Update fields
	if input.StageName != nil {
		stage.StageName = *input.StageName
	}
	if input.StageKey != nil {
		stage.StageKey = *input.StageKey
	}
	if input.StageOrder != nil {
		stage.StageOrder = int(*input.StageOrder)
	}
	if input.Description != nil {
		stage.Description = *input.Description
	}

	// Save the updated stage
	err = r.StageService.UpdateStage(stage)
	if err != nil {
		return nil, fmt.Errorf("failed to update stage: %w", err)
	}

	return stage, nil
}

// DeleteStage is the resolver for the deleteStage field.
func (r *mutationResolver) DeleteStage(ctx context.Context, stageID string) (*bool, error) {
	id, err := strconv.Atoi(stageID)
	if err != nil {
		return nil, fmt.Errorf("invalid stage ID format: %w", err)
	}

	err = r.StageService.DeleteStage(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete stage: %w", err)
	}

	success := true
	return &success, nil
}

// AssignMetricToStage is the resolver for the assignMetricToStage field.
func (r *mutationResolver) AssignMetricToStage(ctx context.Context, input model.StageMetricInput) (*bool, error) {
	stageID, err := strconv.Atoi(input.StageID)
	if err != nil {
		return nil, fmt.Errorf("invalid stage ID format: %w", err)
	}

	metricID, err := strconv.Atoi(input.MetricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	err = r.StageService.AssociateMetricWithStage(stageID, metricID)
	if err != nil {
		return nil, fmt.Errorf("failed to assign metric to stage: %w", err)
	}

	success := true
	return &success, nil
}

// RemoveMetricFromStage is the resolver for the removeMetricFromStage field.
func (r *mutationResolver) RemoveMetricFromStage(ctx context.Context, input model.StageMetricInput) (*bool, error) {
	stage_id, err := strconv.Atoi(input.StageID)
	if err != nil {
		return nil, fmt.Errorf("invalid stage metric ID format: %w", err)
	}

	metric_id, err := strconv.Atoi(input.MetricID)
	if err != nil {
		return nil, fmt.Errorf("invalid stage metric ID format: %w", err)
	}

	err = r.StageService.RemoveMetricFromStage(stage_id, metric_id)
	if err != nil {
		return nil, fmt.Errorf("failed to remove metric from stage: %w", err)
	}

	success := true
	return &success, nil
}

// CreateGameMetric is the resolver for the createGameMetric field.
func (r *mutationResolver) CreateGameMetric(ctx context.Context, input model.GameMetricInput) (*models.GameMetric, error) {
	metric := &models.GameMetric{
		GameID:      input.GameID,
		MetricKey:   input.MetricKey,
		MetricName:  input.MetricName,
		Formula:     input.Formula,
		Description: *input.Description,
	}

	err := r.MetricService.CreateGameMetric(metric)
	if err != nil {
		return nil, fmt.Errorf("failed to create game metric: %w", err)
	}

	return metric, nil
}

// UpdateGameMetric is the resolver for the updateGameMetric field.
func (r *mutationResolver) UpdateGameMetric(ctx context.Context, input model.GameMetricUpdateInput) (*models.GameMetric, error) {
	metricID, err := strconv.Atoi(input.MetricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	// Fetch the existing metric
	metric, err := r.MetricService.GetGameMetricByID(metricID)
	if err != nil {
		return nil, fmt.Errorf("failed to find game metric: %w", err)
	}

	if metric == nil {
		return nil, fmt.Errorf("game metric not found with ID: %s", input.MetricID)
	}

	// Update fields
	if input.MetricKey != nil {
		metric.MetricKey = *input.MetricKey
	}
	if input.MetricName != nil {
		metric.MetricName = *input.MetricName
	}
	if input.Formula != nil {
		metric.Formula = *input.Formula
	}
	if input.Description != nil {
		metric.Description = *input.Description
	}

	// Save the updated metric
	err = r.MetricService.UpdateGameMetric(metric)
	if err != nil {
		return nil, fmt.Errorf("failed to update game metric: %w", err)
	}

	return metric, nil
}

// DeleteGameMetric is the resolver for the deleteGameMetric field.
func (r *mutationResolver) DeleteGameMetric(ctx context.Context, metricID string) (*bool, error) {
	id, err := strconv.Atoi(metricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	err = r.MetricService.DeleteGameMetric(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete game metric: %w", err)
	}

	success := true
	return &success, nil
}

// CreateGameMetricParameter is the resolver for the createGameMetricParameter field.
func (r *mutationResolver) CreateGameMetricParameter(ctx context.Context, input model.GameMetricParameterInput) (*models.GameMetricParameter, error) {
	metricID, err := strconv.Atoi(input.MetricID)
	if err != nil {
		return nil, fmt.Errorf("invalid metric ID format: %w", err)
	}

	parameter := &models.GameMetricParameter{
		MetricID:    metricID,
		ParamKey:    input.ParamKey,
		ParamName:   input.ParamName,
		Description: *input.Description,
		ParamType:   input.ParamType,
		IsRequired:  *input.IsRequired,
	}

	err = r.MetricService.CreateGameMetricParameter(parameter)
	if err != nil {
		return nil, fmt.Errorf("failed to create game metric parameter: %w", err)
	}

	return parameter, nil
}

// UpdateGameMetricParameter is the resolver for the updateGameMetricParameter field.
func (r *mutationResolver) UpdateGameMetricParameter(ctx context.Context, input model.GameMetricParameterUpdateInput) (*models.GameMetricParameter, error) {
	paramID, err := strconv.Atoi(input.ParamID)
	if err != nil {
		return nil, fmt.Errorf("invalid parameter ID format: %w", err)
	}

	// Fetch the existing parameter
	parameter, err := r.MetricService.GetGameMetricParameterByID(paramID)
	if err != nil {
		return nil, fmt.Errorf("failed to find game metric parameter: %w", err)
	}

	if parameter == nil {
		return nil, fmt.Errorf("game metric parameter not found with ID: %s", input.ParamID)
	}

	// Update fields
	if input.ParamKey != nil {
		parameter.ParamKey = *input.ParamKey
	}
	if input.ParamName != nil {
		parameter.ParamName = *input.ParamName
	}
	if input.Description != nil {
		parameter.Description = *input.Description
	}
	if input.ParamType != nil {
		parameter.ParamType = *input.ParamType
	}
	if input.IsRequired != nil {
		parameter.IsRequired = *input.IsRequired
	}

	// Save the updated parameter
	err = r.MetricService.UpdateGameMetricParameter(parameter)
	if err != nil {
		return nil, fmt.Errorf("failed to update game metric parameter: %w", err)
	}

	return parameter, nil
}

// DeleteGameMetricParameter is the resolver for the deleteGameMetricParameter field.
func (r *mutationResolver) DeleteGameMetricParameter(ctx context.Context, paramID string) (*bool, error) {
	id, err := strconv.Atoi(paramID)
	if err != nil {
		return nil, fmt.Errorf("invalid parameter ID format: %w", err)
	}

	err = r.MetricService.DeleteGameMetricParameter(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete game metric parameter: %w", err)
	}

	success := true
	return &success, nil
}

// CreateConstantParameter is the resolver for the createConstantParameter field.
func (r *mutationResolver) CreateConstantParameter(ctx context.Context, input model.ConstantParameterInput) (*models.ConstantParameter, error) {
	constant := &models.ConstantParameter{
		GameID:      input.GameID,
		ConstKey:    input.ConstKey,
		ConstName:   input.ConstName,
		ConstValue:  input.ConstValue,
		Description: *input.Description,
	}

	err := r.ConstantParameterService.CreateConstantParameter(constant)
	if err != nil {
		return nil, fmt.Errorf("failed to create constant parameter: %w", err)
	}

	return constant, nil
}

// UpdateConstantParameter is the resolver for the updateConstantParameter field.
func (r *mutationResolver) UpdateConstantParameter(ctx context.Context, input model.ConstantParameterUpdateInput) (*models.ConstantParameter, error) {
	constID, err := strconv.Atoi(input.ConstID)
	if err != nil {
		return nil, fmt.Errorf("invalid constant ID format: %w", err)
	}

	// Fetch the existing constant
	constant, err := r.MetricService.GetConstantParameterByID(constID)
	if err != nil {
		return nil, fmt.Errorf("failed to find constant parameter: %w", err)
	}

	if constant == nil {
		return nil, fmt.Errorf("constant parameter not found with ID: %s", input.ConstID)
	}

	// Update fields
	if input.ConstKey != nil {
		constant.ConstKey = *input.ConstKey
	}
	if input.ConstName != nil {
		constant.ConstName = *input.ConstName
	}
	if input.ConstValue != nil {
		constant.ConstValue = *input.ConstValue
	}
	if input.Description != nil {
		constant.Description = *input.Description
	}

	// Save the updated constant
	err = r.ConstantParameterService.UpdateConstantParameter(constant)
	if err != nil {
		return nil, fmt.Errorf("failed to update constant parameter: %w", err)
	}

	return constant, nil
}

// DeleteConstantParameter is the resolver for the deleteConstantParameter field.
func (r *mutationResolver) DeleteConstantParameter(ctx context.Context, constID string) (*bool, error) {
	id, err := strconv.Atoi(constID)
	if err != nil {
		return nil, fmt.Errorf("invalid constant ID format: %w", err)
	}

	err = r.ConstantParameterService.DeleteConstantParameter(id)
	if err != nil {
		return nil, fmt.Errorf("failed to delete constant parameter: %w", err)
	}

	success := true
	return &success, nil
}

// CalculatePlayerPerformance is the resolver for the calculatePlayerPerformance field.
func (r *mutationResolver) CalculatePlayerPerformance(ctx context.Context, input model.PlayerPerformanceInput) (*model.PlayerPerformance, error) {
	// Convert input parameters to the format expected by the service
	playerPerformanceInput := &services.PlayerPerformanceInput{
		PlayerID:    input.PlayerID,
		PlayerName:  input.PlayerName,
		ProfileType: *input.ProfileType,
		GameID:      input.GameID,
	}

	// Convert stage parameters
	for _, stage := range input.StageParameters {
		// Convert StageID from string to int
		stageID, err := strconv.Atoi(stage.StageID)
		if err != nil {
			return nil, fmt.Errorf("invalid stage ID format: %w", err)
		}

		stageParams := services.StageParametersInput{
			StageID:    stageID,
			Parameters: make(map[string]interface{}),
			TimeTaken:  stage.TimeTaken,
		}

		// Copy parameters
		for _, param := range stage.Parameters {
			stageParams.Parameters[param.ParamID] = param.Value
		}

		playerPerformanceInput.StageParameters = append(playerPerformanceInput.StageParameters, stageParams)
	}

	// Call the service to calculate performance
	result, err := r.PlayerPerformanceService.CalculatePlayerPerformance(*playerPerformanceInput)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate player performance: %w", err)
	}

	// Convert the result to the GraphQL model
	performance := &model.PlayerPerformance{
		GameID:     input.GameID,
		TotalScore: &result.TotalScore,
	}

	// Add competence scores
	for key, comp := range result.CompetenceDetails {
		compData, ok := comp.(map[string]interface{})
		if !ok {
			continue
		}

		competenceScore := &model.CompetenceDetail{
			CompetenceKey: key,
		}

		if name, ok := compData["name"].(string); ok {
			competenceScore.Name = &name
		}
		if score, ok := compData["score"].(float64); ok {
			competenceScore.Score = &score
		}
		if benchmark, ok := compData["benchmark"].(float64); ok {
			competenceScore.Benchmark = &benchmark
		}
		if weight, ok := compData["weight"].(float64); ok {
			competenceScore.Weight = &weight
		}

		performance.CompetenceDetails = append(performance.CompetenceDetails, competenceScore)
	}

	return performance, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
